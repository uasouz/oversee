package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"oversee/collector/graphql/graph/model"
	"oversee/collector/persistence"
)

// ListAuditLogs is the resolver for the listAuditLogs field.
func (r *queryResolver) ListAuditLogs(ctx context.Context, cursor *model.Cursor) ([]*model.AuditLogEvent, error) {
	cursorID := ""
	var cursorTimeStamp int64

	if cursor != nil {
		cursorID = cursor.ID
		cursorTimeStamp = cursor.Timestamp.Unix()
	}

	// Use the SearchService to list logs
	logs, err := r.SearchService.ListLogs(ctx, cursorTimeStamp, cursorID)
	if err != nil {
		fmt.Println("Wth")
		return nil, err
	}

	// Convert []*core.Log to []*model.AuditLogEvent
	var auditLogEvents []*model.AuditLogEvent
	for _, log := range logs {
		fmt.Println(log)
		auditLogEvents = append(auditLogEvents, &model.AuditLogEvent{
			ID:          log.ID.String(),
			Timestamp:   log.Timestamp,
			ServiceName: log.ServiceName,
			Operation:   log.Operation,
			ActorID:     log.ActorId,
			ActorType:   log.ActorType,
			Metadata:    log.Metadata,
		})
	}

	return auditLogEvents, nil
}

// SearchAuditLogs is the resolver for the searchAuditLogs field.
func (r *queryResolver) SearchAuditLogs(ctx context.Context, query model.SearchQuery) ([]*model.AuditLogEvent, error) {
	// Convert the model.SearchQuery to persistence.SearchQuery
	persistenceQuery := persistence.SearchQuery{}

	if query.ServiceName != nil {
		persistenceQuery.ServiceName = *query.ServiceName
	}
	if query.Operation != nil {
		persistenceQuery.Operation = *query.Operation
	}

	if query.ActorID != nil {
		persistenceQuery.ActorID = *query.ActorID
	}

	//if query.AffectedResources != nil {
	//	persistenceQuery.AffectedResources = query.AffectedResources
	//}

	if query.Cursor != nil {
		persistenceQuery.CursorID = query.Cursor.ID
		persistenceQuery.CursorTimestamp = query.Cursor.Timestamp.Unix()
	}

	// Use the SearchService to search logs
	logs, err := r.SearchService.SearchLogs(ctx, persistenceQuery)
	if err != nil {
		return nil, err
	}

	// Convert []*core.Log to []*model.AuditLogEvent
	var auditLogEvents []*model.AuditLogEvent
	for _, log := range logs {
		auditLogEvents = append(auditLogEvents, &model.AuditLogEvent{
			ID:          log.ID.String(),
			Timestamp:   log.Timestamp,
			ServiceName: log.ServiceName,
			Operation:   log.Operation,
			ActorID:     log.ActorId,
			ActorType:   log.ActorType,
			Metadata:    log.Metadata,
		})
	}

	return auditLogEvents, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
